{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OGC API Registry","text":"<p>A Python library for fetching, storing, and validating OGC API OpenAPI documents.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>HTTP Client: Fetch remote OpenAPI specifications in JSON or YAML format</li> <li>In-Memory Registry: Store specifications as immutable Pydantic objects indexed by type and version</li> <li>Strategy Pattern Validation: Validate OpenAPI documents based on OGC API conformance classes</li> <li>Auto-Detection: Automatically detect OGC API types from conformance classes or document structure</li> </ul>"},{"location":"#supported-ogc-api-types","title":"Supported OGC API Types","text":"API Type Description Common Base functionality shared by all OGC APIs Features Vector feature data access (Part 1, 2, 3) Tiles Tiled data access Maps Map image generation Processes Processing services Records Catalog/metadata services Coverages Coverage data access EDR Environmental Data Retrieval Styles Style management Routes Routing services"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from ogcapi_registry import validate_ogc_api\n\n# Validate an OpenAPI document\nresult = validate_ogc_api(\n    document,\n    conformance_classes=[\n        \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    ]\n)\n\nif result.is_valid:\n    print(\"Document is valid!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error['message']}\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Using uv\nuv add ogcapi-registry\n\n# Using pip\npip install ogcapi-registry\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Architecture - System design and patterns</li> <li>Usage Guide - Detailed API usage examples</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>This document describes the architecture of the OGC API Registry library, including the design patterns used and the component structure.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>The library is built around two main architectural patterns:</p> <ol> <li>Registry Pattern: For storing and retrieving OpenAPI specifications</li> <li>Strategy Pattern: For validating documents based on OGC API conformance classes</li> </ol>"},{"location":"architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    subgraph \"Client Layer\"\n        OC[OpenAPIClient]\n        AOC[AsyncOpenAPIClient]\n    end\n\n    subgraph \"Registry Layer\"\n        SR[SpecificationRegistry]\n        ASR[AsyncSpecificationRegistry]\n        OGCR[OGCSpecificationRegistry]\n    end\n\n    subgraph \"Validation Layer\"\n        STR[StrategyRegistry]\n        OV[OpenAPIValidator]\n    end\n\n    subgraph \"Strategy Layer\"\n        VS[ValidationStrategy]\n        CS[CommonStrategy]\n        FS[FeaturesStrategy]\n        TS[TilesStrategy]\n        PS[ProcessesStrategy]\n        OS[Other Strategies...]\n    end\n\n    subgraph \"OGC Types\"\n        SK[OGCSpecificationKey]\n        CC[ConformanceClass]\n        AT[OGCAPIType]\n    end\n\n    OC --&gt; SR\n    OC --&gt; OGCR\n    AOC --&gt; ASR\n    SR --&gt; OV\n    OGCR --&gt; STR\n    STR --&gt; VS\n    VS --&gt; CS\n    VS --&gt; FS\n    VS --&gt; TS\n    VS --&gt; PS\n    VS --&gt; OS\n    OV --&gt; STR\n    CC --&gt; SK\n    SK --&gt; OGCR\n    AT --&gt; SK</code></pre>"},{"location":"architecture/#strategy-pattern-implementation","title":"Strategy Pattern Implementation","text":"<p>The Strategy pattern is the core of the OGC API validation system. It allows different validation logic to be applied based on the conformance classes declared by an API implementation.</p>"},{"location":"architecture/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class ValidationStrategy {\n        &lt;&lt;abstract&gt;&gt;\n        +api_type: OGCAPIType\n        +required_conformance_patterns: list\n        +optional_conformance_patterns: list\n        +validate(document, conformance_classes) ValidationResult\n        +get_required_paths(conformance_classes) list\n        +get_required_operations(conformance_classes) dict\n        +matches_conformance(conformance_classes) bool\n        +get_conformance_score(conformance_classes) int\n    }\n\n    class CommonStrategy {\n        +api_type = COMMON\n        +validate()\n        +get_required_paths()\n        +get_required_operations()\n    }\n\n    class FeaturesStrategy {\n        +api_type = FEATURES\n        +validate()\n        +get_required_paths()\n        +get_required_operations()\n        -_validate_collections_endpoint()\n        -_validate_items_endpoint()\n        -_validate_crs_support()\n    }\n\n    class TilesStrategy {\n        +api_type = TILES\n        +validate()\n        +get_required_paths()\n        +get_required_operations()\n        -_validate_tileset_endpoint()\n        -_validate_tile_endpoint()\n    }\n\n    class ProcessesStrategy {\n        +api_type = PROCESSES\n        +validate()\n        +get_required_paths()\n        +get_required_operations()\n        -_validate_execution_endpoint()\n        -_validate_jobs_endpoint()\n    }\n\n    class CompositeValidationStrategy {\n        -strategies: list\n        +validate()\n        +get_required_paths()\n        +get_required_operations()\n    }\n\n    class StrategyRegistry {\n        -strategies: dict\n        +register(strategy)\n        +get(api_type) ValidationStrategy\n        +get_for_conformance(conformance_classes) ValidationStrategy\n        +detect_and_validate(document, conformance_classes) ValidationResult\n    }\n\n    ValidationStrategy &lt;|-- CommonStrategy\n    ValidationStrategy &lt;|-- FeaturesStrategy\n    ValidationStrategy &lt;|-- TilesStrategy\n    ValidationStrategy &lt;|-- ProcessesStrategy\n    ValidationStrategy &lt;|-- CompositeValidationStrategy\n    StrategyRegistry o-- ValidationStrategy</code></pre>"},{"location":"architecture/#strategy-selection-flow","title":"Strategy Selection Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant StrategyRegistry\n    participant Strategy\n    participant Document\n\n    Client-&gt;&gt;StrategyRegistry: detect_and_validate(document, conformance_classes)\n\n    alt No conformance classes provided\n        StrategyRegistry-&gt;&gt;Document: Extract from x-conformance\n        StrategyRegistry-&gt;&gt;Document: Infer from paths\n    end\n\n    StrategyRegistry-&gt;&gt;StrategyRegistry: get_for_conformance(conformance_classes)\n\n    loop For each registered strategy\n        StrategyRegistry-&gt;&gt;Strategy: matches_conformance(conformance_classes)\n        Strategy--&gt;&gt;StrategyRegistry: true/false\n    end\n\n    alt Multiple strategies match\n        StrategyRegistry-&gt;&gt;StrategyRegistry: Create CompositeValidationStrategy\n    end\n\n    StrategyRegistry-&gt;&gt;Strategy: validate(document, conformance_classes)\n    Strategy-&gt;&gt;Strategy: get_required_paths()\n    Strategy-&gt;&gt;Strategy: validate_paths_exist()\n    Strategy-&gt;&gt;Strategy: validate_operations_exist()\n    Strategy--&gt;&gt;StrategyRegistry: ValidationResult\n    StrategyRegistry--&gt;&gt;Client: ValidationResult</code></pre>"},{"location":"architecture/#component-details","title":"Component Details","text":""},{"location":"architecture/#ogc-api-types","title":"OGC API Types","text":"<p>The <code>OGCAPIType</code> enum defines all supported OGC API specification types:</p> <pre><code>class OGCAPIType(str, Enum):\n    COMMON = \"ogcapi-common\"\n    FEATURES = \"ogcapi-features\"\n    TILES = \"ogcapi-tiles\"\n    MAPS = \"ogcapi-maps\"\n    PROCESSES = \"ogcapi-processes\"\n    RECORDS = \"ogcapi-records\"\n    COVERAGES = \"ogcapi-coverages\"\n    EDR = \"ogcapi-edr\"\n    STYLES = \"ogcapi-styles\"\n    ROUTES = \"ogcapi-routes\"\n</code></pre>"},{"location":"architecture/#conformance-classes","title":"Conformance Classes","text":"<p>Conformance classes are URIs that identify specific capabilities an API supports. The library uses them to:</p> <ol> <li>Detect API Type: Each conformance class URI contains patterns that identify the API type</li> <li>Select Validation Strategy: The appropriate strategy is chosen based on matching conformance patterns</li> <li>Determine Required Features: Within a strategy, conformance classes determine which paths and operations are required</li> </ol> <pre><code>graph LR\n    CC[Conformance Class URI] --&gt; DT{Detect Type}\n    DT --&gt;|\"contains 'features'\"| F[Features]\n    DT --&gt;|\"contains 'tiles'\"| T[Tiles]\n    DT --&gt;|\"contains 'processes'\"| P[Processes]\n    DT --&gt;|\"contains 'common'\"| C[Common]\n    DT --&gt;|\"unknown\"| C</code></pre>"},{"location":"architecture/#validation-strategy-behavior","title":"Validation Strategy Behavior","text":"<p>Each strategy validates documents according to conformance class requirements:</p> Strategy Core Requirements Conformance-Dependent Common <code>/</code>, <code>/conformance</code> <code>/api</code> (oas30) Features <code>/collections</code>, <code>/collections/{id}/items</code> CRS params (crs), Filter params (filter) Tiles <code>/tiles</code> (dataset) or collection tiles TileMatrixSets list (tilesets-list) Processes <code>/processes</code>, <code>/processes/{id}/execution</code> <code>/jobs</code> list (job-list), DELETE job (dismiss) Records <code>/collections/{id}/items</code> with <code>q</code> param Sorting, CQL filter EDR Collection query endpoints Position, Area, Cube, Trajectory, Corridor"},{"location":"architecture/#composite-strategy","title":"Composite Strategy","text":"<p>When an API declares conformance to multiple OGC API types (e.g., Features + Tiles), the <code>CompositeValidationStrategy</code> combines validation from all relevant strategies:</p> <pre><code>graph TB\n    subgraph \"Composite Strategy\"\n        CV[CompositeValidationStrategy]\n        CV --&gt; FS[FeaturesStrategy]\n        CV --&gt; TS[TilesStrategy]\n    end\n\n    FS --&gt; FR[Features Results]\n    TS --&gt; TR[Tiles Results]\n    FR --&gt; MR[Merged Results]\n    TR --&gt; MR</code></pre>"},{"location":"architecture/#data-models","title":"Data Models","text":""},{"location":"architecture/#immutable-models","title":"Immutable Models","text":"<p>All data models use Pydantic with <code>frozen=True</code> for immutability:</p> <pre><code>classDiagram\n    class SpecificationKey {\n        &lt;&lt;frozen&gt;&gt;\n        +spec_type: SpecificationType\n        +version: str\n    }\n\n    class SpecificationMetadata {\n        &lt;&lt;frozen&gt;&gt;\n        +source_url: str\n        +fetched_at: datetime\n        +content_type: str\n        +etag: str\n    }\n\n    class RegisteredSpecification {\n        &lt;&lt;frozen&gt;&gt;\n        +key: SpecificationKey\n        +metadata: SpecificationMetadata\n        +raw_content: dict\n        +openapi_version: str\n        +info_title: str\n    }\n\n    class ValidationResult {\n        &lt;&lt;frozen&gt;&gt;\n        +is_valid: bool\n        +errors: tuple\n        +warnings: tuple\n        +validated_against: SpecificationKey\n    }\n\n    class ConformanceClass {\n        &lt;&lt;frozen&gt;&gt;\n        +uri: str\n        +api_type: OGCAPIType\n        +is_core: bool\n        +version: str\n    }\n\n    RegisteredSpecification --&gt; SpecificationKey\n    RegisteredSpecification --&gt; SpecificationMetadata</code></pre>"},{"location":"architecture/#thread-safety","title":"Thread Safety","text":"<p>The <code>SpecificationRegistry</code> uses a reentrant lock (<code>threading.RLock</code>) to ensure thread-safe operations:</p> <ul> <li>All read/write operations acquire the lock</li> <li>Iteration returns a copy of the data to avoid modification during iteration</li> <li>Immutable models prevent accidental modifications</li> </ul>"},{"location":"architecture/#ogc-specification-registry","title":"OGC Specification Registry","text":"<p>The <code>OGCSpecificationRegistry</code> stores reference OGC API specifications indexed by API type, version, and part number.</p>"},{"location":"architecture/#class-diagram_1","title":"Class Diagram","text":"<pre><code>classDiagram\n    class OGCSpecificationKey {\n        &lt;&lt;frozen&gt;&gt;\n        +api_type: OGCAPIType\n        +spec_version: str\n        +part: int | None\n        +matches(other, strict) bool\n        +__hash__() int\n        +__str__() str\n    }\n\n    class OGCRegisteredSpecification {\n        +key: OGCSpecificationKey\n        +raw_content: dict\n        +metadata: SpecificationMetadata\n        +openapi_version: str\n        +info_title: str\n        +paths: dict\n    }\n\n    class OGCSpecificationRegistry {\n        -specs: dict\n        -lock: RLock\n        +register(api_type, version, content) OGCRegisteredSpecification\n        +register_from_url(api_type, version, url) OGCRegisteredSpecification\n        +get(api_type, version, part) OGCRegisteredSpecification\n        +get_latest(api_type) OGCRegisteredSpecification\n        +list_versions(api_type) list\n        +list_by_type(api_type) list\n    }\n\n    OGCSpecificationRegistry o-- OGCRegisteredSpecification\n    OGCRegisteredSpecification --&gt; OGCSpecificationKey</code></pre>"},{"location":"architecture/#version-aware-validation-flow","title":"Version-Aware Validation Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant StrategyRegistry\n    participant OGCRegistry as OGCSpecificationRegistry\n    participant Strategy\n\n    Client-&gt;&gt;StrategyRegistry: validate_against_spec(doc, spec_key, ogc_registry)\n    StrategyRegistry-&gt;&gt;StrategyRegistry: get(spec_key.api_type)\n    StrategyRegistry-&gt;&gt;Strategy: supports_version(spec_key.spec_version)\n    Strategy--&gt;&gt;StrategyRegistry: true\n\n    StrategyRegistry-&gt;&gt;Strategy: validate(doc, conformance_classes)\n    Strategy--&gt;&gt;StrategyRegistry: ValidationResult\n\n    StrategyRegistry-&gt;&gt;OGCRegistry: get(api_type, version, part)\n    OGCRegistry--&gt;&gt;StrategyRegistry: OGCRegisteredSpecification\n\n    StrategyRegistry-&gt;&gt;StrategyRegistry: Compare paths with reference\n    StrategyRegistry--&gt;&gt;Client: ValidationResult with warnings</code></pre>"},{"location":"architecture/#specification-key-matching","title":"Specification Key Matching","text":"<p>The <code>OGCSpecificationKey</code> supports two matching modes:</p> Mode Description Example Strict Exact version and part match <code>1.0</code> matches <code>1.0</code> only Non-strict Major.minor version match <code>1.0</code> matches <code>1.0.1</code>"},{"location":"architecture/#protocols-and-duck-typing","title":"Protocols and Duck Typing","text":"<p>The library uses Python's <code>Protocol</code> classes to enable structural subtyping (duck typing). This allows custom implementations without inheritance.</p>"},{"location":"architecture/#protocol-hierarchy","title":"Protocol Hierarchy","text":"<pre><code>classDiagram\n    class ValidationStrategyProtocol {\n        &lt;&lt;protocol&gt;&gt;\n        +api_type: OGCAPIType\n        +validate(document, conformance_classes) ValidationResult\n        +get_required_paths(conformance_classes) list\n        +get_required_operations(conformance_classes) dict\n        +matches_conformance(conformance_classes) bool\n    }\n\n    class VersionAwareStrategyProtocol {\n        &lt;&lt;protocol&gt;&gt;\n        +supports_version(spec_version) bool\n        +get_spec_version_from_conformance(conformance_classes) str\n        +get_specification_key(conformance_classes) OGCSpecificationKey\n    }\n\n    class OpenAPIClientProtocol {\n        &lt;&lt;protocol&gt;&gt;\n        +fetch(url) tuple\n        +fetch_and_validate_structure(url) tuple\n    }\n\n    class RegistryProtocol~K, V~ {\n        &lt;&lt;protocol&gt;&gt;\n        +get_by_key(key) V\n        +exists_by_key(key) bool\n        +remove_by_key(key) bool\n        +list_keys() list~K~\n        +clear() None\n    }\n\n    ValidationStrategyProtocol &lt;|-- VersionAwareStrategyProtocol\n    ValidationStrategy ..|&gt; ValidationStrategyProtocol : implements\n    ValidationStrategy ..|&gt; VersionAwareStrategyProtocol : implements</code></pre>"},{"location":"architecture/#runtime-checkable-protocols","title":"Runtime Checkable Protocols","text":"<p>All protocols are decorated with <code>@runtime_checkable</code>, enabling isinstance() checks:</p> <pre><code>from ogcapi_registry import ValidationStrategyProtocol\n\nclass MyStrategy:\n    api_type = OGCAPIType.FEATURES\n    # ... implement required methods ...\n\n# Works at runtime\nassert isinstance(MyStrategy(), ValidationStrategyProtocol)\n</code></pre>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<p>The architecture supports several extension points:</p>"},{"location":"architecture/#custom-strategies","title":"Custom Strategies","text":"<p>You have two options for creating custom strategies:</p> <p>Option 1: Inherit from ValidationStrategy (ABC)</p> <pre><code>class CustomStrategy(ValidationStrategy):\n    api_type = OGCAPIType.CUSTOM  # Add to enum first\n    required_conformance_patterns = [\"my-custom-api\"]\n\n    def validate(self, document, conformance_classes):\n        # Custom validation logic\n        pass\n\n    def get_required_paths(self, conformance_classes):\n        return [\"/custom-endpoint\"]\n\n    def get_required_operations(self, conformance_classes):\n        return {\"/custom-endpoint\": [\"get\", \"post\"]}\n</code></pre> <p>Option 2: Duck Typing with Protocol (No Inheritance)</p> <pre><code>class CustomStrategy:\n    \"\"\"No inheritance required - just implement the interface.\"\"\"\n\n    api_type = OGCAPIType.FEATURES\n\n    def validate(self, document, conformance_classes):\n        return ValidationResult.success()\n\n    def get_required_paths(self, conformance_classes):\n        return [\"/custom-endpoint\"]\n\n    def get_required_operations(self, conformance_classes):\n        return {\"/custom-endpoint\": [\"get\", \"post\"]}\n\n    def matches_conformance(self, conformance_classes):\n        return True\n\n# Register without inheritance\nregistry = StrategyRegistry()\nregistry.register(CustomStrategy())  # Works!\n</code></pre>"},{"location":"architecture/#custom-conformance-detection","title":"Custom Conformance Detection","text":"<p>Override <code>_infer_conformance_from_paths</code> in <code>StrategyRegistry</code> to add custom path-based detection.</p>"},{"location":"architecture/#prepost-validation-hooks","title":"Pre/Post Validation Hooks","text":"<p>Wrap strategies or extend <code>CompositeValidationStrategy</code> to add hooks before/after validation.</p>"},{"location":"examples/","title":"Examples and Validation Workflow","text":"<p>This document provides detailed examples and explains the complete workflow for validating OGC API implementations.</p>"},{"location":"examples/#validating-a-real-ogc-api-server","title":"Validating a Real OGC API Server","text":""},{"location":"examples/#workflow-overview","title":"Workflow Overview","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server as OGC API Server\n    participant Library as ogcapi-registry\n\n    Client-&gt;&gt;Server: GET /api?f=json\n    Server--&gt;&gt;Client: OpenAPI Document\n\n    Client-&gt;&gt;Server: GET /conformance?f=json\n    Server--&gt;&gt;Client: Conformance Classes\n\n    Client-&gt;&gt;Library: parse_conformance_classes()\n    Library--&gt;&gt;Client: List[ConformanceClass]\n\n    Client-&gt;&gt;Library: get_specification_keys()\n    Library--&gt;&gt;Client: Set[OGCSpecificationKey]\n\n    Client-&gt;&gt;Library: validate_ogc_api(doc, conformance)\n    Library--&gt;&gt;Client: ValidationResult\n\n    Client-&gt;&gt;Library: find_missing_conformance()\n    Library--&gt;&gt;Client: Missing Classes Report</code></pre>"},{"location":"examples/#step-1-fetch-the-openapi-document","title":"Step 1: Fetch the OpenAPI Document","text":"<pre><code>from ogcapi_registry import OpenAPIClient\n\nclient = OpenAPIClient(timeout=30.0)\n\n# OGC APIs serve OpenAPI at /api endpoint\nbase_url = \"https://demo.ldproxy.net/daraa\"\ncontent, metadata = client.fetch(f\"{base_url}/api?f=json\")\n\nprint(f\"Title: {content['info']['title']}\")\nprint(f\"OpenAPI Version: {content['openapi']}\")\nprint(f\"Paths: {len(content['paths'])}\")\n</code></pre>"},{"location":"examples/#step-2-fetch-conformance-classes","title":"Step 2: Fetch Conformance Classes","text":"<pre><code>from ogcapi_registry import parse_conformance_classes\n\n# Fetch from /conformance endpoint\nconformance_response, _ = client.fetch(f\"{base_url}/conformance?f=json\")\n\n# Parse into ConformanceClass objects\nconformance_classes = parse_conformance_classes(conformance_response)\n\nfor cc in conformance_classes:\n    print(f\"- {cc.conformance_class_name} ({cc.api_type.display_name} v{cc.spec_version})\")\n</code></pre>"},{"location":"examples/#step-3-analyze-specification-coverage","title":"Step 3: Analyze Specification Coverage","text":"<pre><code>from ogcapi_registry import (\n    get_specification_keys,\n    group_conformance_by_spec,\n)\n\n# Get unique specification keys\nspec_keys = get_specification_keys(conformance_classes)\n\nprint(\"Implemented Specifications:\")\nfor key in spec_keys:\n    print(f\"  - {key}\")\n    # Output: OGC API - Features Part 1 v1.0\n\n# Group conformance classes by specification\ngroups = group_conformance_by_spec(conformance_classes)\n\nfor spec_key, classes in groups.items():\n    print(f\"\\n{spec_key}:\")\n    for cc in classes:\n        print(f\"  - {cc.conformance_class_name}\")\n</code></pre>"},{"location":"examples/#step-4-identify-missing-conformance-classes","title":"Step 4: Identify Missing Conformance Classes","text":"<pre><code># Known conformance classes for OGC API - Features Part 1\nFEATURES_PART1_CLASSES = {\n    \"core\": \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    \"oas30\": \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas30\",\n    \"html\": \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/html\",\n    \"geojson\": \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson\",\n    \"gmlsf0\": \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/gmlsf0\",  # Optional\n    \"gmlsf2\": \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/gmlsf2\",  # Optional\n}\n\n# Find which are not declared\ndeclared_uris = {cc.uri.lower() for cc in conformance_classes}\n\nmissing = []\nfor name, uri in FEATURES_PART1_CLASSES.items():\n    if uri.lower() not in declared_uris:\n        missing.append(name)\n\nprint(\"Missing conformance classes:\")\nfor name in missing:\n    print(f\"  - {name}\")\n</code></pre>"},{"location":"examples/#step-5-validate-the-openapi-document","title":"Step 5: Validate the OpenAPI Document","text":"<pre><code>from ogcapi_registry import validate_ogc_api\n\nresult = validate_ogc_api(content, conformance_classes)\n\nif result.is_valid:\n    print(\"\u2705 Document is valid!\")\nelse:\n    print(\"\u274c Validation failed:\")\n    for error in result.errors:\n        print(f\"  - [{error['type']}] {error['message']}\")\n\nif result.warnings:\n    print(\"\u26a0\ufe0f Warnings:\")\n    for warning in result.warnings:\n        print(f\"  - {warning['message']}\")\n</code></pre>"},{"location":"examples/#step-6-version-aware-validation-optional","title":"Step 6: Version-Aware Validation (Optional)","text":"<pre><code>from ogcapi_registry import (\n    StrategyRegistry,\n    OGCSpecificationRegistry,\n    OGCSpecificationKey,\n    OGCAPIType,\n)\n\n# Create registries\nstrategy_registry = StrategyRegistry()\nogc_registry = OGCSpecificationRegistry()\n\n# Register official reference specification\nogc_registry.register_from_url(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    url=\"https://schemas.opengis.net/ogcapi/features/part1/1.0/openapi/ogcapi-features-1.yaml\",\n    part=1,\n)\n\n# Validate against specific version\nspec_key = OGCSpecificationKey(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    part=1,\n)\n\nresult = strategy_registry.validate_against_spec(\n    document=content,\n    spec_key=spec_key,\n    ogc_registry=ogc_registry,\n    conformance_classes=conformance_classes,\n)\n</code></pre>"},{"location":"examples/#complete-example-script","title":"Complete Example Script","text":"<p>A complete example script is available at <code>examples/validate_ogc_api_server.py</code>:</p> <pre><code># Run the demo with simulated data\npython -m examples.validate_ogc_api_server\n</code></pre>"},{"location":"examples/#example-output-explained","title":"Example Output Explained","text":"<pre><code>============================================================\nDEMO: Simulated OGC API - Features Validation\n============================================================\n\n1. OpenAPI Document:\n   Title: Daraa\n   Version: 3.0.3\n   Paths: 7\n</code></pre> <p>Explanation: The OpenAPI document was successfully parsed. It uses OpenAPI 3.0.3 specification and defines 7 API paths.</p> <pre><code>2. Declared Conformance Classes (9):\n   - core (OGC API - Features)\n   - oas30 (OGC API - Features)\n   - html (OGC API - Features)\n   - geojson (OGC API - Features)\n   - crs (OGC API - Features)\n   - core (OGC API - Common)\n   - landing-page (OGC API - Common)\n   - oas30 (OGC API - Common)\n   - json (OGC API - Common)\n</code></pre> <p>Explanation: The server declares 9 conformance classes across multiple OGC API specifications:</p> Conformance Class Meaning <code>core</code> (Features) Implements the basic Features API functionality <code>oas30</code> (Features) API definition follows OpenAPI 3.0 specification <code>html</code> (Features) Supports HTML output format <code>geojson</code> (Features) Supports GeoJSON feature encoding <code>crs</code> (Features Part 2) Supports coordinate reference system handling <code>core</code> (Common) Implements OGC API Common core requirements <code>landing-page</code> (Common) Provides a landing page at <code>/</code> <code>oas30</code> (Common) Common API follows OpenAPI 3.0 <code>json</code> (Common) Supports JSON output format <pre><code>3. Specification Coverage:\n   - OGC API - Features Part 1 v1.0\n   - OGC API - Features Part 2 v1.0\n   - OGC API - Common Part 1 v1.0\n</code></pre> <p>Explanation: Based on the conformance URIs, the server implements three OGC specifications. The version is extracted from the conformance class URI pattern: <pre><code>http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\n                                             ^^^\n                                             version\n</code></pre></p> <pre><code>4. Missing Conformance Classes:\n   OGC API - Features Part 1:\n     - gmlsf0 (optional)\n     - gmlsf2 (optional)\n   OGC API - Common Part 1:\n     - html (optional)\n</code></pre> <p>Explanation: These conformance classes are defined in the specifications but not declared by this server:</p> Missing Class Why It's Missing Impact <code>gmlsf0</code> Server doesn't support GML Simple Features Level 0 encoding No GML output available <code>gmlsf2</code> Server doesn't support GML Simple Features Level 2 encoding No GML output available <code>html</code> (Common) HTML output for Common endpoints not implemented API responses only in JSON <p>These are optional conformance classes, so their absence is not an error.</p> <pre><code>5. Validation Result:\n   Valid: False\n   Compliant: False\n\n   Error Summary:\n     Critical: 2 (must fix)\n     Warnings: 5 (optional)\n     Info:     0 (recommendations)\n\n   CRITICAL ERRORS:\n     - Collections GET should have a 200 response\n     - Items endpoint should have 'limit' query parameter\n\n   WARNINGS:\n     - Items endpoint should have 'bbox' query parameter for spatial filtering\n     - CRS conformance requires 'crs' query parameter (for crs)\n     - CRS conformance requires 'bbox-crs' query parameter (for crs)\n</code></pre>"},{"location":"examples/#understanding-error-severity","title":"Understanding Error Severity","text":"<p>The library categorizes validation errors by severity to help you prioritize fixes:</p> Severity Meaning Action Required CRITICAL Violates required OGC conformance Must fix for compliance WARNING Violates optional conformance class Should fix if you declared that conformance INFO Best practice recommendation Consider implementing <p>In the example above:</p> <ul> <li><code>Valid: False</code> - Document has errors of some kind</li> <li><code>Compliant: False</code> - Document has CRITICAL errors (not OGC compliant)</li> </ul> <p>If there were only warnings (no critical errors), you would see: <pre><code>   Valid: False\n   Compliant: True    # No critical errors!\n</code></pre></p>"},{"location":"examples/#using-severity-filtering-in-code","title":"Using Severity Filtering in Code","text":"<pre><code>from ogcapi_registry import validate_ogc_api, ErrorSeverity\n\nresult = validate_ogc_api(document, conformance_classes)\n\n# Check compliance (ignores warnings)\nif result.is_compliant:\n    print(\"No critical errors - document is OGC compliant!\")\n\n# Get summary\nsummary = result.get_summary()\nprint(f\"Critical: {summary['critical']}, Warnings: {summary['warning']}\")\n\n# Filter by severity\nfor error in result.critical_errors:\n    print(f\"MUST FIX: {error['message']}\")\n\nfor error in result.warning_errors:\n    print(f\"SHOULD FIX: {error['message']}\")\n</code></pre> <p>Explanation of Each Error:</p>"},{"location":"examples/#critical-collections-get-should-have-a-200-response","title":"CRITICAL: \"Collections GET should have a 200 response\"","text":"<p>Severity: CRITICAL (required for OGC compliance)</p> <p>Cause: The <code>/collections</code> endpoint in the OpenAPI document doesn't define a <code>200</code> response.</p> <p>OGC Requirement: OGC API - Features Part 1, Requirement 11 states that the collections endpoint MUST return a 200 response with the list of collections.</p> <p>Fix: Add a 200 response to the path definition: <pre><code>paths:\n  /collections:\n    get:\n      responses:\n        '200':\n          description: List of feature collections\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Collections'\n</code></pre></p>"},{"location":"examples/#critical-items-endpoint-should-have-limit-query-parameter","title":"CRITICAL: \"Items endpoint should have 'limit' query parameter\"","text":"<p>Severity: CRITICAL (required for OGC compliance)</p> <p>Cause: The <code>/collections/{collectionId}/items</code> endpoint doesn't define the <code>limit</code> parameter.</p> <p>OGC Requirement: OGC API - Features Part 1, Requirement 17 states that the items endpoint MUST support the <code>limit</code> parameter for pagination.</p> <p>Fix: Add the limit parameter: <pre><code>paths:\n  /collections/{collectionId}/items:\n    get:\n      parameters:\n        - name: limit\n          in: query\n          description: Maximum number of features to return\n          schema:\n            type: integer\n            minimum: 1\n            maximum: 10000\n            default: 10\n</code></pre></p>"},{"location":"examples/#warning-items-endpoint-should-have-bbox-query-parameter","title":"WARNING: \"Items endpoint should have 'bbox' query parameter\"","text":"<p>Severity: WARNING (recommended, but not strictly required for minimal compliance)</p> <p>Cause: The items endpoint doesn't define spatial filtering via <code>bbox</code>.</p> <p>OGC Requirement: OGC API - Features Part 1, Requirement 19 states that the items endpoint SHOULD support the <code>bbox</code> parameter for spatial filtering. While technically required by the specification, some minimal implementations may omit it.</p> <p>Fix: Add the bbox parameter: <pre><code>parameters:\n  - name: bbox\n    in: query\n    description: Bounding box for spatial filtering\n    style: form\n    explode: false\n    schema:\n      type: array\n      items:\n        type: number\n      minItems: 4\n      maxItems: 6\n</code></pre></p>"},{"location":"examples/#warning-crs-conformance-requires-crs-query-parameter","title":"WARNING: \"CRS conformance requires 'crs' query parameter\"","text":"<p>Severity: WARNING (only required if you declared CRS conformance)</p> <p>Cause: The server declares CRS conformance (Features Part 2) but the items endpoint doesn't include the <code>crs</code> parameter.</p> <p>OGC Requirement: OGC API - Features Part 2, Requirement 4 states that when CRS conformance is declared, the <code>crs</code> parameter MUST be available.</p> <p>Why WARNING: CRS is an optional conformance class. If you don't need CRS support, remove it from your <code>/conformance</code> response instead of adding the parameter.</p> <p>Fix: Add the crs parameter: <pre><code>parameters:\n  - name: crs\n    in: query\n    description: Coordinate reference system for returned features\n    schema:\n      type: string\n      format: uri\n</code></pre></p>"},{"location":"examples/#warning-crs-conformance-requires-bbox-crs-query-parameter","title":"WARNING: \"CRS conformance requires 'bbox-crs' query parameter\"","text":"<p>Severity: WARNING (only required if you declared CRS conformance)</p> <p>Cause: When CRS conformance is declared, <code>bbox-crs</code> must be available to specify the CRS of the bbox parameter.</p> <p>OGC Requirement: OGC API - Features Part 2, Requirement 5.</p> <p>Why WARNING: Same as above - CRS is an optional conformance class.</p> <p>Fix: Add the bbox-crs parameter: <pre><code>parameters:\n  - name: bbox-crs\n    in: query\n    description: CRS of the bbox parameter values\n    schema:\n      type: string\n      format: uri\n</code></pre></p>"},{"location":"examples/#conformance-class-reference","title":"Conformance Class Reference","text":""},{"location":"examples/#ogc-api-features","title":"OGC API - Features","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-features-1/1.0/conf/core</code> Required Basic feature access Part 1 <code>oas30</code> <code>.../ogcapi-features-1/1.0/conf/oas30</code> Required OpenAPI 3.0 definition Part 1 <code>html</code> <code>.../ogcapi-features-1/1.0/conf/html</code> Optional HTML encoding Part 1 <code>geojson</code> <code>.../ogcapi-features-1/1.0/conf/geojson</code> Optional GeoJSON encoding Part 1 <code>gmlsf0</code> <code>.../ogcapi-features-1/1.0/conf/gmlsf0</code> Optional GML SF-0 encoding Part 1 <code>gmlsf2</code> <code>.../ogcapi-features-1/1.0/conf/gmlsf2</code> Optional GML SF-2 encoding Part 2 <code>crs</code> <code>.../ogcapi-features-2/1.0/conf/crs</code> Optional CRS support"},{"location":"examples/#ogc-api-common","title":"OGC API - Common","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-common-1/1.0/conf/core</code> Required Core API requirements Part 1 <code>landing-page</code> <code>.../ogcapi-common-1/1.0/conf/landing-page</code> Required Landing page at <code>/</code> Part 1 <code>oas30</code> <code>.../ogcapi-common-1/1.0/conf/oas30</code> Optional OpenAPI 3.0 definition Part 1 <code>html</code> <code>.../ogcapi-common-1/1.0/conf/html</code> Optional HTML encoding Part 1 <code>json</code> <code>.../ogcapi-common-1/1.0/conf/json</code> Optional JSON encoding Part 2 <code>collections</code> <code>.../ogcapi-common-2/1.0/conf/collections</code> Optional Collection resources"},{"location":"examples/#ogc-api-tiles","title":"OGC API - Tiles","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-tiles-1/1.0/conf/core</code> Required Core tile access Part 1 <code>tileset</code> <code>.../ogcapi-tiles-1/1.0/conf/tileset</code> Required Tileset metadata Part 1 <code>dataset-tilesets</code> <code>.../ogcapi-tiles-1/1.0/conf/dataset-tilesets</code> Optional Dataset-level tiles Part 1 <code>geodata-tilesets</code> <code>.../ogcapi-tiles-1/1.0/conf/geodata-tilesets</code> Optional Geodata tiles"},{"location":"examples/#ogc-api-processes","title":"OGC API - Processes","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-processes-1/1.0/conf/core</code> Required Core process execution Part 1 <code>ogc-process-description</code> <code>.../ogcapi-processes-1/1.0/conf/ogc-process-description</code> Optional Process descriptions Part 1 <code>job-list</code> <code>.../ogcapi-processes-1/1.0/conf/job-list</code> Optional Job listing Part 1 <code>dismiss</code> <code>.../ogcapi-processes-1/1.0/conf/dismiss</code> Optional Job cancellation Part 1 <code>callback</code> <code>.../ogcapi-processes-1/1.0/conf/callback</code> Optional Async callbacks"},{"location":"examples/#ogc-api-edr-environmental-data-retrieval","title":"OGC API - EDR (Environmental Data Retrieval)","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-edr-1/1.0/conf/core</code> Required Core EDR functionality Part 1 <code>collections</code> <code>.../ogcapi-edr-1/1.0/conf/collections</code> Optional Collection support Part 1 <code>position</code> <code>.../ogcapi-edr-1/1.0/conf/position</code> Optional Point queries Part 1 <code>area</code> <code>.../ogcapi-edr-1/1.0/conf/area</code> Optional Area queries Part 1 <code>cube</code> <code>.../ogcapi-edr-1/1.0/conf/cube</code> Optional Cube queries Part 1 <code>trajectory</code> <code>.../ogcapi-edr-1/1.0/conf/trajectory</code> Optional Trajectory queries Part 1 <code>corridor</code> <code>.../ogcapi-edr-1/1.0/conf/corridor</code> Optional Corridor queries"},{"location":"examples/#ogc-api-coverages","title":"OGC API - Coverages","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-coverages-1/1.0/conf/core</code> Required Core coverage access Part 1 <code>geodata-coverage</code> <code>.../ogcapi-coverages-1/1.0/conf/geodata-coverage</code> Optional Geodata coverages"},{"location":"examples/#ogc-api-maps","title":"OGC API - Maps","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-maps-1/1.0/conf/core</code> Required Core map rendering Part 1 <code>dataset-map</code> <code>.../ogcapi-maps-1/1.0/conf/dataset-map</code> Optional Dataset maps Part 1 <code>geodata-map</code> <code>.../ogcapi-maps-1/1.0/conf/geodata-map</code> Optional Geodata maps"},{"location":"examples/#ogc-api-styles","title":"OGC API - Styles","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-styles-1/1.0/conf/core</code> Required Core style management Part 1 <code>manage-styles</code> <code>.../ogcapi-styles-1/1.0/conf/manage-styles</code> Optional CRUD operations Part 1 <code>validation</code> <code>.../ogcapi-styles-1/1.0/conf/validation</code> Optional Style validation"},{"location":"examples/#ogc-api-routes","title":"OGC API - Routes","text":"Part Conformance Class URI Required/Optional Description Part 1 <code>core</code> <code>.../ogcapi-routes-1/1.0/conf/core</code> Required Core routing Part 1 <code>manage-routes</code> <code>.../ogcapi-routes-1/1.0/conf/manage-routes</code> Optional Route management"},{"location":"examples/#validation-error-types","title":"Validation Error Types","text":"<p>The library produces different error types to help categorize issues:</p> Error Type Description Severity <code>missing_required_path</code> A required API endpoint is not defined Error <code>missing_required_operation</code> A required HTTP method is not defined for a path Error <code>missing_parameter</code> A required query/path parameter is missing Error <code>missing_response</code> A required response code is not defined Error <code>unsupported_version</code> The declared spec version is not supported Error <code>missing_reference_path</code> A path from reference spec is not found Warning <code>version_mismatch</code> OpenAPI version differs from expected Warning"},{"location":"examples/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"examples/#issue-validation-passes-but-server-doesnt-work","title":"Issue: \"Validation passes but server doesn't work\"","text":"<p>Cause: The library validates the OpenAPI document structure, not the actual server implementation.</p> <p>Solution: Use tools like the OGC CITE test suite for runtime compliance testing.</p>"},{"location":"examples/#issue-too-many-missing-conformance-class-warnings","title":"Issue: \"Too many missing conformance class warnings\"","text":"<p>Cause: The server may implement a minimal subset of the specification.</p> <p>Solution: Focus on required conformance classes first. Optional classes can be implemented incrementally.</p>"},{"location":"examples/#issue-cannot-parse-conformance-classes","title":"Issue: \"Cannot parse conformance classes\"","text":"<p>Cause: The conformance URI format may not match expected patterns.</p> <p>Solution: Verify URIs follow the pattern: <pre><code>http://www.opengis.net/spec/ogcapi-{type}-{part}/{version}/conf/{class}\n</code></pre></p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide covers all the ways to use the OGC API Registry library for fetching, storing, and validating OpenAPI documents.</p>"},{"location":"usage/#installation","title":"Installation","text":"uvpip <pre><code>uv add ogcapi-registry\n</code></pre> <pre><code>pip install ogcapi-registry\n</code></pre>"},{"location":"usage/#quick-start","title":"Quick Start","text":"<p>The simplest way to validate an OGC API document:</p> <pre><code>from ogcapi_registry import validate_ogc_api\n\ndocument = {\n    \"openapi\": \"3.0.3\",\n    \"info\": {\"title\": \"My Features API\", \"version\": \"1.0.0\"},\n    \"paths\": {\n        \"/\": {\"get\": {\"responses\": {\"200\": {\"description\": \"OK\"}}}},\n        \"/conformance\": {\"get\": {\"responses\": {\"200\": {\"description\": \"OK\"}}}},\n        \"/collections\": {\"get\": {\"responses\": {\"200\": {\"description\": \"OK\"}}}},\n        # ... more paths\n    }\n}\n\nresult = validate_ogc_api(document, [\n    \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\"\n])\n\nif result.is_valid:\n    print(\"Valid OGC API - Features document!\")\nelse:\n    for error in result.errors:\n        print(f\"Error at {error['path']}: {error['message']}\")\n</code></pre>"},{"location":"usage/#fetching-remote-specifications","title":"Fetching Remote Specifications","text":""},{"location":"usage/#synchronous-client","title":"Synchronous Client","text":"<pre><code>from ogcapi_registry import OpenAPIClient\n\nclient = OpenAPIClient(\n    timeout=30.0,  # Request timeout in seconds\n    follow_redirects=True\n)\n\n# Fetch and parse a specification\ncontent, metadata = client.fetch(\"https://example.com/api/openapi.json\")\n\nprint(f\"Fetched from: {metadata.source_url}\")\nprint(f\"Content type: {metadata.content_type}\")\nprint(f\"ETag: {metadata.etag}\")\nprint(f\"API Title: {content['info']['title']}\")\n</code></pre>"},{"location":"usage/#asynchronous-client","title":"Asynchronous Client","text":"<pre><code>import asyncio\nfrom ogcapi_registry import AsyncOpenAPIClient\n\nasync def fetch_spec():\n    client = AsyncOpenAPIClient(timeout=30.0)\n    content, metadata = await client.fetch(\"https://example.com/api/openapi.yaml\")\n    return content\n\ndocument = asyncio.run(fetch_spec())\n</code></pre>"},{"location":"usage/#fetch-with-structural-validation","title":"Fetch with Structural Validation","text":"<pre><code>from ogcapi_registry import OpenAPIClient\nfrom ogcapi_registry.exceptions import ParseError\n\nclient = OpenAPIClient()\n\ntry:\n    # This validates basic OpenAPI structure (openapi field, info, etc.)\n    content, metadata = client.fetch_and_validate_structure(\n        \"https://example.com/api/openapi.json\"\n    )\nexcept ParseError as e:\n    print(f\"Invalid specification: {e}\")\n</code></pre>"},{"location":"usage/#specification-registry","title":"Specification Registry","text":"<p>The registry stores OpenAPI specifications as immutable objects indexed by type and version.</p>"},{"location":"usage/#registering-specifications","title":"Registering Specifications","text":"<pre><code>from ogcapi_registry import (\n    SpecificationRegistry,\n    SpecificationType,\n    SpecificationMetadata,\n)\n\nregistry = SpecificationRegistry()\n\n# Register from a URL (auto-detects type and version)\nspec = registry.register_from_url(\"https://example.com/openapi.json\")\nprint(f\"Registered: {spec.key.spec_type} v{spec.key.version}\")\n\n# Register manually with explicit type/version\nregistry.register(\n    content={\n        \"openapi\": \"3.0.3\",\n        \"info\": {\"title\": \"Reference API\", \"version\": \"1.0.0\"},\n        \"paths\": {}\n    },\n    spec_type=SpecificationType.OPENAPI_3_0,\n    version=\"3.0.3\",\n    metadata=SpecificationMetadata(source_url=\"local\"),\n)\n\n# Overwrite existing specification\nregistry.register(\n    content=updated_content,\n    spec_type=SpecificationType.OPENAPI_3_0,\n    version=\"3.0.3\",\n    overwrite=True,  # Required to replace existing\n)\n</code></pre>"},{"location":"usage/#querying-the-registry","title":"Querying the Registry","text":"<pre><code>from ogcapi_registry import SpecificationRegistry, SpecificationType\n\nregistry = SpecificationRegistry()\n# ... register some specs ...\n\n# Check if a spec exists\nif registry.exists(SpecificationType.OPENAPI_3_0, \"3.0.3\"):\n    spec = registry.get(SpecificationType.OPENAPI_3_0, \"3.0.3\")\n    print(f\"Found: {spec.info_title}\")\n\n# List all registered specs\nfor spec in registry:\n    print(f\"{spec.key.spec_type}: {spec.key.version}\")\n\n# Get all keys\nkeys = registry.list_keys()\n\n# Remove a specification\nregistry.remove(SpecificationType.OPENAPI_3_0, \"3.0.3\")\n\n# Clear all specifications\nregistry.clear()\n</code></pre>"},{"location":"usage/#async-registry","title":"Async Registry","text":"<pre><code>import asyncio\nfrom ogcapi_registry import AsyncSpecificationRegistry\n\nasync def main():\n    registry = AsyncSpecificationRegistry()\n\n    # Async fetch and register\n    spec = await registry.register_from_url(\"https://example.com/openapi.json\")\n\n    # Sync operations still work\n    if registry.exists(spec.key.spec_type, spec.key.version):\n        print(\"Registered successfully!\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/#ogc-api-validation","title":"OGC API Validation","text":""},{"location":"usage/#using-conformance-classes","title":"Using Conformance Classes","text":"<p>The library validates documents based on OGC API conformance classes. You can provide them in several formats:</p> <pre><code>from ogcapi_registry import validate_ogc_api, ConformanceClass\n\n# As a list of strings\nresult = validate_ogc_api(document, [\n    \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson\",\n])\n\n# As ConformanceClass objects\nresult = validate_ogc_api(document, [\n    ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\"),\n])\n\n# As a dict with conformsTo key (like /conformance response)\nresult = validate_ogc_api(document, {\n    \"conformsTo\": [\n        \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    ]\n})\n\n# Auto-detect from document (infers from paths or x-conformance extension)\nresult = validate_ogc_api(document)\n</code></pre>"},{"location":"usage/#working-with-conformance-classes","title":"Working with Conformance Classes","text":"<pre><code>from ogcapi_registry import (\n    ConformanceClass,\n    OGCAPIType,\n    parse_conformance_classes,\n    detect_api_types,\n    get_primary_api_type,\n)\n\n# Parse conformance classes\nccs = parse_conformance_classes([\n    \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    \"http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core\",\n])\n\n# Detect all API types\ntypes = detect_api_types(ccs)\nprint(types)  # {OGCAPIType.FEATURES, OGCAPIType.TILES}\n\n# Get the primary (most specific) type\nprimary = get_primary_api_type(ccs)\nprint(primary)  # OGCAPIType.FEATURES\n\n# Inspect a conformance class\ncc = ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\")\nprint(cc.api_type)   # OGCAPIType.FEATURES\nprint(cc.is_core)    # True\nprint(cc.version)    # \"1.0\"\n</code></pre>"},{"location":"usage/#validation-results","title":"Validation Results","text":"<pre><code>from ogcapi_registry import validate_ogc_api\n\nresult = validate_ogc_api(document, conformance_classes)\n\n# Check validity\nif result.is_valid:\n    print(\"Document is valid!\")\n    if result.warnings:\n        print(\"But there are warnings:\")\n        for warning in result.warnings:\n            print(f\"  - {warning['message']}\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.errors:\n        print(f\"  [{error['path']}] {error['message']} (type: {error['type']})\")\n\n# Access validation metadata\nif result.validated_against:\n    print(f\"Validated as: {result.validated_against.spec_type}\")\n</code></pre>"},{"location":"usage/#error-severity-levels","title":"Error Severity Levels","text":"<p>The library distinguishes between different error severities to help prioritize issues:</p> Severity Description Example CRITICAL Must be fixed for OGC compliance Missing required path <code>/collections</code> WARNING Optional conformance class issues Missing <code>bbox</code> parameter (recommended) INFO Best practices and recommendations Missing <code>filter</code> parameter for filter conformance <pre><code>from ogcapi_registry import validate_ogc_api, ErrorSeverity\n\nresult = validate_ogc_api(document, conformance_classes)\n\n# Get error summary by severity\nsummary = result.get_summary()\nprint(f\"Critical: {summary['critical']}, Warnings: {summary['warning']}, Info: {summary['info']}\")\n\n# Filter errors by severity\ncritical_errors = result.critical_errors\nwarning_errors = result.warning_errors\ninfo_errors = result.info_errors\n\n# Or use the generic method\ncritical = result.get_errors_by_severity(ErrorSeverity.CRITICAL)\n\n# Check compliance vs validity\n# is_valid: No errors at all\n# is_compliant: No CRITICAL errors (warnings/info are acceptable)\nif result.is_compliant:\n    print(\"Document is OGC compliant (no critical errors)\")\n    if not result.is_valid:\n        print(f\"  But has {len(result.warning_errors)} warnings to review\")\nelse:\n    print(\"Document has critical compliance issues:\")\n    for error in result.critical_errors:\n        print(f\"  - {error['message']}\")\n</code></pre>"},{"location":"usage/#understanding-compliance-vs-validity","title":"Understanding Compliance vs Validity","text":"<p>The distinction between <code>is_valid</code> and <code>is_compliant</code> helps you decide what to fix:</p> <ul> <li><code>is_valid</code>: <code>True</code> only if there are zero errors of any severity</li> <li><code>is_compliant</code>: <code>True</code> if there are no CRITICAL errors (warnings and info are acceptable)</li> </ul> <p>This is useful because:</p> <ol> <li>A document can be compliant but not valid - it meets required OGC specs but has optional issues</li> <li>A document with only warnings may be perfectly acceptable for production use</li> <li>Focus on fixing CRITICAL errors first, then address warnings incrementally</li> </ol>"},{"location":"usage/#using-the-strategy-registry","title":"Using the Strategy Registry","text":"<p>For more control over validation, use the <code>StrategyRegistry</code> directly:</p> <pre><code>from ogcapi_registry import (\n    StrategyRegistry,\n    ConformanceClass,\n    OGCAPIType,\n)\n\n# Create a registry with all default strategies\nregistry = StrategyRegistry()\n\n# List available strategies\nfor strategy in registry.list_strategies():\n    print(f\"{strategy.api_type}: {strategy.required_conformance_patterns}\")\n\n# Get a specific strategy\nfeatures_strategy = registry.get(OGCAPIType.FEATURES)\n\n# Get the best strategy for conformance classes\nccs = [ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\")]\nstrategy = registry.get_for_conformance(ccs)\nprint(f\"Selected strategy: {strategy.api_type}\")\n\n# Validate with auto-detection\nresult = registry.detect_and_validate(document, ccs)\n</code></pre>"},{"location":"usage/#using-individual-strategies","title":"Using Individual Strategies","text":"<pre><code>from ogcapi_registry import FeaturesStrategy, ConformanceClass\n\nstrategy = FeaturesStrategy()\n\n# Check what paths are required\nccs = [\n    ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\"),\n    ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-2/1.0/conf/crs\"),\n]\n\nrequired_paths = strategy.get_required_paths(ccs)\nprint(\"Required paths:\", required_paths)\n# ['/collections', '/collections/{collectionId}', '/collections/{collectionId}/items', ...]\n\nrequired_ops = strategy.get_required_operations(ccs)\nprint(\"Required operations:\", required_ops)\n# {'/collections': ['get'], '/collections/{collectionId}/items': ['get'], ...}\n\n# Validate a document\nresult = strategy.validate(document, ccs)\n</code></pre>"},{"location":"usage/#basic-openapi-validation","title":"Basic OpenAPI Validation","text":"<p>For non-OGC-specific OpenAPI validation:</p> <pre><code>from ogcapi_registry import (\n    validate_document,\n    validate_openapi_structure,\n    validate_openapi_with_pydantic,\n    parse_openapi_content,\n)\n\n# Parse content (JSON or YAML)\ncontent = parse_openapi_content(yaml_string, format_hint=\"yaml\")\n\n# Validate structure (JSON Schema validation)\nresult = validate_openapi_structure(content)\n\n# Validate with Pydantic (stricter, OpenAPI 3.1 only)\nresult = validate_openapi_with_pydantic(content)\n\n# Combined validation\nresult = validate_document(content)\n</code></pre>"},{"location":"usage/#validating-against-reference-specifications","title":"Validating Against Reference Specifications","text":"<pre><code>from ogcapi_registry import (\n    SpecificationRegistry,\n    OpenAPIValidator,\n    validate_against_reference,\n    SpecificationType,\n)\n\n# Using OpenAPIValidator with a registry\nregistry = SpecificationRegistry()\nregistry.register_from_url(\"https://example.com/reference-api.json\")\n\nvalidator = OpenAPIValidator(registry)\n\n# Validate against a specific registered spec\nresult = validator.validate_against(\n    document,\n    spec_type=SpecificationType.OPENAPI_3_0,\n    version=\"3.0.3\",\n    strict=True,  # Require exact version match\n)\n\n# Validate against the latest version of a type\nresult = validator.validate_against_latest(\n    document,\n    spec_type=SpecificationType.OPENAPI_3_0,\n)\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<pre><code>from ogcapi_registry import (\n    OpenAPIClient,\n    SpecificationRegistry,\n    SpecificationType,\n)\nfrom ogcapi_registry.exceptions import (\n    FetchError,\n    ParseError,\n    SpecificationNotFoundError,\n    SpecificationAlreadyExistsError,\n    ValidationError,\n)\n\nclient = OpenAPIClient()\nregistry = SpecificationRegistry()\n\n# Handle fetch errors\ntry:\n    content, metadata = client.fetch(\"https://invalid-url.example.com/api.json\")\nexcept FetchError as e:\n    print(f\"Failed to fetch from {e.url}: {e.reason}\")\n\n# Handle parse errors\ntry:\n    content, metadata = client.fetch_and_validate_structure(\"https://example.com/api.json\")\nexcept ParseError as e:\n    print(f\"Parse error: {e.reason} (source: {e.source})\")\n\n# Handle registry errors\ntry:\n    registry.register(content, SpecificationType.OPENAPI_3_0, \"3.0.3\")\n    registry.register(content, SpecificationType.OPENAPI_3_0, \"3.0.3\")  # Duplicate!\nexcept SpecificationAlreadyExistsError as e:\n    print(f\"Spec already exists: {e.spec_type} v{e.version}\")\n\ntry:\n    spec = registry.get(SpecificationType.OPENAPI_3_0, \"9.9.9\")\nexcept SpecificationNotFoundError as e:\n    print(f\"Spec not found: {e.spec_type} v{e.version}\")\n</code></pre>"},{"location":"usage/#complete-example-validating-an-ogc-api-features-implementation","title":"Complete Example: Validating an OGC API - Features Implementation","text":"<pre><code>import json\nfrom ogcapi_registry import (\n    OpenAPIClient,\n    SpecificationRegistry,\n    StrategyRegistry,\n    validate_ogc_api,\n    OGCAPIType,\n)\n\n# 1. Fetch the OpenAPI document\nclient = OpenAPIClient()\ndocument, metadata = client.fetch_and_validate_structure(\n    \"https://my-ogc-api.example.com/api\"\n)\n\nprint(f\"Fetched: {document['info']['title']}\")\n\n# 2. Fetch conformance classes from the API\nconformance_response, _ = client.fetch(\n    \"https://my-ogc-api.example.com/conformance\"\n)\nconformance_classes = conformance_response.get(\"conformsTo\", [])\n\nprint(f\"Conformance classes: {len(conformance_classes)}\")\n\n# 3. Validate the document\nresult = validate_ogc_api(document, conformance_classes)\n\n# 4. Report results\nif result.is_valid:\n    print(\"\u2705 Document is valid!\")\n    print(f\"   Validated as: {result.validated_against.spec_type if result.validated_against else 'unknown'}\")\nelse:\n    print(\"\u274c Validation failed:\")\n    for error in result.errors:\n        print(f\"   - [{error['type']}] {error['path']}: {error['message']}\")\n\n# 5. Show warnings if any\nif result.warnings:\n    print(\"\u26a0\ufe0f Warnings:\")\n    for warning in result.warnings:\n        print(f\"   - {warning['message']}\")\n</code></pre>"},{"location":"usage/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"usage/#1-always-provide-conformance-classes","title":"1. Always Provide Conformance Classes","text":"<p>While the library can infer API types from paths, providing explicit conformance classes ensures accurate validation:</p> <pre><code># Good: explicit conformance\nresult = validate_ogc_api(document, conformance_classes)\n\n# Less accurate: auto-detection\nresult = validate_ogc_api(document)  # May miss some requirements\n</code></pre>"},{"location":"usage/#2-use-the-appropriate-validation-level","title":"2. Use the Appropriate Validation Level","text":"<ul> <li><code>validate_ogc_api()</code>: Full OGC API validation with conformance-aware strategies</li> <li><code>validate_document()</code>: Basic OpenAPI validation</li> <li><code>validate_openapi_structure()</code>: Lightweight structural validation only</li> </ul>"},{"location":"usage/#3-handle-multi-api-implementations","title":"3. Handle Multi-API Implementations","text":"<p>For APIs that implement multiple OGC API types, the library automatically uses a composite strategy:</p> <pre><code># This API implements both Features and Tiles\nconformance = [\n    \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    \"http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core\",\n]\n\n# Both Features and Tiles requirements will be validated\nresult = validate_ogc_api(document, conformance)\n</code></pre>"},{"location":"usage/#4-store-specifications-for-reference","title":"4. Store Specifications for Reference","text":"<p>Use the registry to cache specifications and avoid repeated fetches:</p> <pre><code>from ogcapi_registry import SpecificationRegistry\n\nregistry = SpecificationRegistry()\n\n# Fetch once\nif not registry.exists(SpecificationType.OPENAPI_3_0, \"3.0.3\"):\n    registry.register_from_url(\"https://example.com/openapi.json\")\n\n# Use cached version\nspec = registry.get(SpecificationType.OPENAPI_3_0, \"3.0.3\")\n</code></pre>"},{"location":"usage/#ogc-specification-registry","title":"OGC Specification Registry","text":"<p>The library includes a dedicated registry for OGC API reference specifications, indexed by API type, version, and part number.</p>"},{"location":"usage/#ogc-specification-keys","title":"OGC Specification Keys","text":"<p>Each OGC API specification is identified by a unique key:</p> <pre><code>from ogcapi_registry import OGCSpecificationKey, OGCAPIType\n\n# Create a specification key\nkey = OGCSpecificationKey(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    part=1,  # Part 1 of OGC API - Features\n)\n\nprint(key)  # \"OGC API - Features Part 1 v1.0\"\n\n# Keys are hashable and can be used in sets/dicts\nkeys = {key}\n\n# Check version compatibility\nkey.matches(other_key, strict=False)  # Matches major.minor only\nkey.matches(other_key, strict=True)   # Exact match required\n</code></pre>"},{"location":"usage/#using-the-ogc-specification-registry","title":"Using the OGC Specification Registry","text":"<pre><code>from ogcapi_registry import (\n    OGCSpecificationRegistry,\n    OGCAPIType,\n    create_default_ogc_registry,\n)\n\n# Create an empty registry\nregistry = OGCSpecificationRegistry()\n\n# Register a specification manually\nspec = registry.register(\n    api_type=OGCAPIType.EDR,\n    spec_version=\"1.1\",\n    raw_content={\n        \"openapi\": \"3.0.3\",\n        \"info\": {\"title\": \"OGC API - EDR\", \"version\": \"1.1.0\"},\n        \"paths\": {\"/\": {}, \"/collections\": {}},\n    },\n    part=1,\n)\n\n# Register from a URL\nspec = registry.register_from_url(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    url=\"https://schemas.opengis.net/ogcapi/features/part1/1.0/openapi/ogcapi-features-1.yaml\",\n    part=1,\n)\n\n# Retrieve a specification\nspec = registry.get(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    part=1,\n)\n\n# Get the latest version of an API type\nlatest = registry.get_latest(api_type=OGCAPIType.EDR)\nprint(f\"Latest EDR version: {latest.key.spec_version}\")\n\n# List all versions of an API type\nversions = registry.list_versions(api_type=OGCAPIType.EDR)\nprint(versions)  # [\"1.1\", \"1.0\"]\n\n# List all specifications of an API type\nedr_specs = registry.list_by_type(api_type=OGCAPIType.EDR)\n</code></pre>"},{"location":"usage/#extracting-specification-information-from-conformance-classes","title":"Extracting Specification Information from Conformance Classes","text":"<pre><code>from ogcapi_registry import (\n    ConformanceClass,\n    get_specification_keys,\n    get_specification_versions,\n    group_conformance_by_spec,\n    OGCAPIType,\n)\n\n# Parse conformance classes\nccs = [\n    ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\"),\n    ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson\"),\n    ConformanceClass(uri=\"http://www.opengis.net/spec/ogcapi-edr-1/1.1/conf/core\"),\n]\n\n# Extract specification keys\nkeys = get_specification_keys(ccs)\n# {OGCSpecificationKey(FEATURES, \"1.0\", 1), OGCSpecificationKey(EDR, \"1.1\", 1)}\n\n# Get versions for a specific API type\nedr_versions = get_specification_versions(ccs, OGCAPIType.EDR)\n# {\"1.1\"}\n\n# Group conformance classes by specification\ngroups = group_conformance_by_spec(ccs)\n# {\n#   OGCSpecificationKey(FEATURES, \"1.0\", 1): [cc1, cc2],\n#   OGCSpecificationKey(EDR, \"1.1\", 1): [cc3],\n# }\n\n# Access specification info from a conformance class\ncc = ccs[0]\nprint(cc.spec_version)           # \"1.0\"\nprint(cc.part)                   # 1\nprint(cc.conformance_class_name) # \"core\"\nprint(cc.specification_key)      # OGCSpecificationKey(FEATURES, \"1.0\", 1)\n</code></pre>"},{"location":"usage/#version-aware-validation","title":"Version-Aware Validation","text":"<p>Validate a document against a specific OGC API specification version:</p> <pre><code>from ogcapi_registry import (\n    StrategyRegistry,\n    OGCSpecificationRegistry,\n    OGCSpecificationKey,\n    OGCAPIType,\n)\n\n# Create registries\nstrategy_registry = StrategyRegistry()\nogc_registry = OGCSpecificationRegistry()\n\n# Register reference specifications\nogc_registry.register_from_url(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    url=\"https://schemas.opengis.net/ogcapi/features/part1/1.0/openapi/ogcapi-features-1.yaml\",\n    part=1,\n)\n\n# Create a specification key for validation target\nspec_key = OGCSpecificationKey(\n    api_type=OGCAPIType.FEATURES,\n    spec_version=\"1.0\",\n    part=1,\n)\n\n# Validate against the specific version\nresult = strategy_registry.validate_against_spec(\n    document=my_openapi_document,\n    spec_key=spec_key,\n    ogc_registry=ogc_registry,\n    conformance_classes=[\n        \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n    ],\n)\n\nif result.is_valid:\n    print(\"Document conforms to OGC API - Features v1.0!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error['message']}\")\n</code></pre>"},{"location":"usage/#detecting-specification-keys-from-documents","title":"Detecting Specification Keys from Documents","text":"<pre><code>from ogcapi_registry import StrategyRegistry\n\nregistry = StrategyRegistry()\n\n# Detect which OGC specifications a document claims to implement\nspec_keys = registry.get_detected_spec_keys(\n    document,\n    conformance_classes=[\n        \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\",\n        \"http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core\",\n    ],\n)\n\nfor key in spec_keys:\n    print(f\"Implements: {key}\")\n    # Implements: OGC API - Features Part 1 v1.0\n    # Implements: OGC API - Tiles Part 1 v1.0\n</code></pre>"},{"location":"usage/#protocols-and-duck-typing","title":"Protocols and Duck Typing","text":"<p>The library supports structural subtyping (duck typing) through Python's <code>Protocol</code> classes. This means you can create custom implementations without inheriting from base classes.</p>"},{"location":"usage/#available-protocols","title":"Available Protocols","text":"Protocol Description <code>ValidationStrategyProtocol</code> Interface for validation strategies <code>VersionAwareStrategyProtocol</code> Extends with version support <code>RegistryProtocol</code> Generic interface for registries <code>OpenAPIClientProtocol</code> HTTP client interface (sync) <code>AsyncOpenAPIClientProtocol</code> HTTP client interface (async) <code>ConformanceClassProtocol</code> Conformance class interface <code>SpecificationKeyProtocol</code> Specification key interface"},{"location":"usage/#creating-a-custom-strategy-no-inheritance-required","title":"Creating a Custom Strategy (No Inheritance Required)","text":"<pre><code>from ogcapi_registry import (\n    OGCAPIType,\n    StrategyRegistry,\n    ValidationResult,\n    ValidationStrategyProtocol,\n)\n\n# Custom strategy WITHOUT inheriting from ValidationStrategy\nclass MyCustomStrategy:\n    \"\"\"A duck-typed strategy - no inheritance needed!\"\"\"\n\n    api_type = OGCAPIType.FEATURES\n\n    def validate(self, document, conformance_classes):\n        # Custom validation logic\n        paths = document.get(\"paths\", {})\n        if \"/my-custom-endpoint\" not in paths:\n            return ValidationResult.failure([{\n                \"path\": \"paths\",\n                \"message\": \"Missing /my-custom-endpoint\",\n                \"type\": \"missing_path\",\n            }])\n        return ValidationResult.success()\n\n    def get_required_paths(self, conformance_classes):\n        return [\"/my-custom-endpoint\", \"/collections\"]\n\n    def get_required_operations(self, conformance_classes):\n        return {\"/my-custom-endpoint\": [\"get\", \"post\"]}\n\n    def matches_conformance(self, conformance_classes):\n        return any(\"features\" in str(cc).lower() for cc in conformance_classes)\n\n# Register and use the custom strategy\nregistry = StrategyRegistry()\nregistry.register(MyCustomStrategy())\n\n# Verify it satisfies the protocol\nassert isinstance(MyCustomStrategy(), ValidationStrategyProtocol)\n</code></pre>"},{"location":"usage/#runtime-protocol-checking","title":"Runtime Protocol Checking","text":"<p>All protocols are decorated with <code>@runtime_checkable</code>, enabling <code>isinstance()</code> checks:</p> <pre><code>from ogcapi_registry import (\n    CommonStrategy,\n    OpenAPIClient,\n    ValidationStrategyProtocol,\n    OpenAPIClientProtocol,\n)\n\n# Check if objects satisfy protocols\nstrategy = CommonStrategy()\nassert isinstance(strategy, ValidationStrategyProtocol)\n\nclient = OpenAPIClient()\nassert isinstance(client, OpenAPIClientProtocol)\n\n# Custom objects are also checkable\nclass MyClient:\n    def fetch(self, url):\n        return {}, None\n\n    def fetch_and_validate_structure(self, url):\n        return {}, None\n\n# This will pass if all required methods are present\nassert isinstance(MyClient(), OpenAPIClientProtocol)\n</code></pre>"},{"location":"usage/#benefits-of-duck-typing","title":"Benefits of Duck Typing","text":"<ol> <li>No Inheritance Required: Create strategies without subclassing</li> <li>Testing: Easy to create mock objects for unit tests</li> <li>Flexibility: External classes can satisfy interfaces</li> <li>Decoupling: Reduced dependencies between modules</li> <li>Type Safety: Full mypy/pyright support for static analysis</li> </ol>"},{"location":"usage/#example-mock-strategy-for-testing","title":"Example: Mock Strategy for Testing","text":"<pre><code>import pytest\nfrom ogcapi_registry import ValidationResult, OGCAPIType\n\nclass MockStrategy:\n    \"\"\"Mock strategy for testing - no inheritance needed.\"\"\"\n\n    api_type = OGCAPIType.COMMON\n\n    def __init__(self, should_pass: bool = True):\n        self.should_pass = should_pass\n        self.validate_called = False\n\n    def validate(self, document, conformance_classes):\n        self.validate_called = True\n        if self.should_pass:\n            return ValidationResult.success()\n        return ValidationResult.failure([{\"message\": \"Mock failure\"}])\n\n    def get_required_paths(self, conformance_classes):\n        return []\n\n    def get_required_operations(self, conformance_classes):\n        return {}\n\n    def matches_conformance(self, conformance_classes):\n        return True\n\ndef test_with_mock_strategy():\n    mock = MockStrategy(should_pass=True)\n    result = mock.validate({}, [])\n\n    assert mock.validate_called\n    assert result.is_valid\n</code></pre>"},{"location":"usage/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"usage/#1-validation-passes-but-server-doesnt-work","title":"1. \"Validation passes but server doesn't work\"","text":"<p>Problem: The OpenAPI document passes validation, but the OGC API server doesn't work correctly when actually used.</p> <p>Technical Explanation: The <code>ogcapi-registry</code> library performs static validation of the OpenAPI document. This means it verifies:</p> <ul> <li>The syntactic structure of the JSON/YAML document</li> <li>The presence of paths required by OGC specifications</li> <li>The correctness of declared HTTP methods</li> <li>Compliance with OpenAPI v3 schemas</li> </ul> <p>However, it does not test runtime behavior of the server. For example:</p> <ul> <li>The <code>/collections</code> path might be declared in the document but return a 500 error</li> <li>Parameters might be documented but not implemented</li> <li>Responses might not match the declared schemas</li> </ul> <p>Solution: Use the OGC CITE Test Suite (Compliance &amp; Interoperability Testing &amp; Evaluation), which executes real HTTP tests against the server to verify that implementations actually comply with the specifications. The CITE suite is the official OGC tool for compliance certification.</p>"},{"location":"usage/#2-too-many-missing-conformance-class-warnings","title":"2. \"Too many missing conformance class warnings\"","text":"<p>Problem: Validation generates many warnings for missing conformance classes, making it difficult to understand what is truly important.</p> <p>Technical Explanation: OGC API specifications define two types of conformance classes:</p> Type Description Example Required Mandatory for base compliance <code>core</code>, <code>oas30</code> Optional Additional functionality <code>html</code>, <code>geojson</code>, <code>crs</code> <p>A server can legitimately implement only a minimal subset. For example, a compliant OGC API - Features server might implement only:</p> <ul> <li><code>http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core</code></li> <li><code>http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas30</code></li> </ul> <p>And completely ignore <code>html</code>, <code>geojson</code>, <code>gmlsf0</code>, etc.</p> <p>Solution: Use the library's severity filtering to prioritize errors:</p> <pre><code>result = validate_ogc_api(document, conformance_classes)\n\n# Focus on critical errors first\nif result.has_critical_errors:\n    print(\"Fix these critical issues:\")\n    for error in result.critical_errors:\n        print(f\"  - {error['message']}\")\nelse:\n    print(\"No critical errors! Review warnings if needed:\")\n    for warning in result.warning_errors:\n        print(f\"  - {warning['message']}\")\n\n# Or use the summary\nsummary = result.get_summary()\nprint(f\"Critical: {summary['critical']}, Warnings: {summary['warning']}\")\n</code></pre> <p>Optional classes can be implemented incrementally based on project needs.</p>"},{"location":"usage/#3-cannot-parse-conformance-classes","title":"3. \"Cannot parse conformance classes\"","text":"<p>Problem: The library cannot interpret the conformance class URIs declared by the server.</p> <p>Technical Explanation: OGC conformance class URIs follow a standardized pattern:</p> <pre><code>http://www.opengis.net/spec/ogcapi-{type}-{part}/{version}/conf/{class}\n</code></pre> <p>Where:</p> <ul> <li><code>{type}</code> = API type (features, tiles, processes, etc.)</li> <li><code>{part}</code> = specification part number (1, 2, 3, etc.)</li> <li><code>{version}</code> = semantic version (1.0, 1.0.0, 2.0, etc.)</li> <li><code>{class}</code> = conformance class name (core, oas30, html, etc.)</li> </ul> <p>Valid Examples: <pre><code>http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\nhttp://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset\nhttp://www.opengis.net/spec/ogcapi-processes-1/1.0/conf/ogc-process-description\n</code></pre></p> <p>Problematic Examples: <pre><code># Wrong prefix\nhttps://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core  # https instead of http\n\n# Non-standard format\nhttp://example.com/ogcapi/features/core  # custom URI\n\n# Malformed version\nhttp://www.opengis.net/spec/ogcapi-features-1/v1.0/conf/core  # \"v1.0\" instead of \"1.0\"\n</code></pre></p> <p>Solution: Verify that URIs in the server's <code>/conformance</code> document exactly follow the OGC pattern. If the server uses custom URIs, extending the library with custom parsers may be necessary.</p>"},{"location":"usage/#next-steps","title":"Next Steps","text":"<p>For complete examples of validating real OGC API servers, including:</p> <ul> <li>Step-by-step validation workflow</li> <li>Detailed explanation of validation errors</li> <li>Conformance class reference tables</li> </ul> <p>See the Examples and Validation Workflow documentation.</p>"}]}